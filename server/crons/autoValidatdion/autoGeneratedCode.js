const moment = require('moment-timezone')

const AutomatedValidations = require('../../models/automatedValidations')
const Validations = require('../../models/validations')
const BrandCollection = require('../../models/brands')
const Rates = require('../../models/rates')
const Places = require('../../models/places')
const { sendAutomationEmail, sendAutomaticValidationSlackMessage, sendAutomaticValidationDiscordMessage } = require('../../services/email')

const {
  Types: { ObjectId }
} = require('mongoose')

async function job(doc, tz) {
  try {
    const updatedValidUntil = updateValidUntil(doc, tz)
    const updatedValidFrom = moment.tz(tz).clone().startOf('day').toDate()
    const validationCode = getRandomValidationCode(doc.validationCodes)
    const ratesData = await Rates.findOne({ _id: doc.rateId })
    const placeData = await Places.findOne({ _id: doc.placeId })
    const brandData = await BrandCollection.findOne({
      userId: ObjectId(placeData.userId)
    })

    const ccEmails = doc.ccEmails.map(val => ({ email: val })).filter(val => val.email !== doc.toEmail)

    await sendAutomationEmail({
      to: [doc.toEmail],
      cc: ccEmails,
      subject: "Automated Validation Code",
    })()({
      brandLogo: brandData?.brandLogo,
      brandName: brandData?.brandName,
      address: brandData?.brandAddress,
      placeAddress: placeData?.lotName,
      rate: ratesData?.displayName,
      rateAmount: ratesData?.amount,
      rateHours: ratesData?.hours,
      rateType: ratesData?.rateType,
      validationCode: validationCode,
      startDate: moment(updatedValidFrom).format("MM-DD-YYYY"),
      endDate: moment(updatedValidUntil).format("MM-DD-YYYY"),
      discount: doc?.discount,
      validationQuantity: doc?.quantity,
    });

    if (doc?.slackChannel) {
      if (doc?.slackChannel.includes("discord")) {
        await sendAutomaticValidationDiscordMessage({
          message: `Automated Validation Code for (${ratesData?.displayName})
          Validation Code: ${validationCode}
          Start Date: ${moment(updatedValidFrom).format("MM-DD-YYYY")}
          End Date: ${moment(updatedValidUntil).format("MM-DD-YYYY")}
          Quantity: ${doc?.quantity}`, discordChannel: doc?.slackChannel
        });
      }
    } else {
      await sendAutomaticValidationSlackMessage({
        message: `Automated Validation Code for (${ratesData?.displayName})
        Validation Code: ${validationCode}
        Start Date: ${moment(updatedValidFrom).format("MM-DD-YYYY")}
        End Date: ${moment(updatedValidUntil).format("MM-DD-YYYY")}
        Quantity: ${doc?.quantity}`, slackChannel: doc?.slackChannel
      });
    }

    const rateIds = doc.rateId;

    rateIds.forEach(async (rateId) => {
      console.log("\n\nCreating validation using this payload", {
        placeId: doc.placeId,
        rateId,
        validationCode: validationCode,
        validFrom: updatedValidFrom,
        validUntil: updatedValidUntil,
        discount: parseInt(doc.discount),
        quantity: parseInt(doc.quantity),
      }, "\n")

      await Validations.create({
        placeId: doc.placeId,
        rateId,
        validationCode: validationCode,
        validFrom: updatedValidFrom,
        validUntil: updatedValidUntil,
        discount: parseInt(doc.discount),
        quantity: parseInt(doc.quantity),
      })
    })
  } catch (error) {
    console.log("\n\nError: ", error, "\n")
    console.log(error?.message || 'Something went wrong')
  }
}

function updateValidUntil(doc, tz) {
  const currentTime = moment.tz(tz);

  if (doc.isDaily) {
    return currentTime.clone().endOf('day').toDate()
  } else if (doc.isWeekly) {
    return currentTime.clone().add(1, 'week').toDate()
  } else if (doc.isMonthly) {
    return currentTime.clone().add(1, 'month').toDate()
  } else if (doc.isYearly) {
    return currentTime.clone().add(1, 'year').toDate()
  } else {
    return doc.validUntil
  }
}

function getRandomValidationCode(validationCodes) {
  const randomIndex = Math.floor(Math.random() * validationCodes.length)
  return validationCodes[randomIndex]
}

const AutoGeneratedCode = async () => {
  try {
    const currentTime = moment().utc()
    const places = await Places.find({ status: 10 })

    for (const place of places) {
      const tz = place?.timeZoneId;
      const placeTime = currentTime.clone().tz(tz);

      const jobStartTime = placeTime
        ?.clone()
        .set({ hour: 3, minute: 0, second: 0, millisecond: 0 })
      const jobEndTime = placeTime
        ?.clone()
        .set({ hour: 3, minute: 14, second: 59, millisecond: 999 })

      if (placeTime?.isBetween(jobStartTime, jobEndTime, null, '[]')) {
        const docs = await AutomatedValidations.find({ placeId: place._id, status: 10 })

        for (const doc of docs) {
          const startDate = moment(doc.validFrom, 'YYYY-MM-DD').utc()
          const endDate = moment(doc.validUntil, 'YYYY-MM-DD').utc()

          if (currentTime.isBetween(startDate, endDate, null, '[]')) {
            if (doc?.isDaily) {
              await job(doc, tz)
            } else if (doc?.isWeekly && currentTime.day() === 1) {
              await job(doc, tz)
            } else if (doc?.isMonthly && currentTime.date() === 1) {
              await job(doc, tz)
            } else if (
              doc?.isYearly &&
              currentTime.month() === 0 &&
              currentTime.date() === 1
            ) {
              await job(doc, tz)
            }
          }
        }
      }
    }
  } catch (error) {
    console.error('Error checking and running jobs:', error)
  }
}

module.exports = AutoGeneratedCode